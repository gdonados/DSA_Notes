[2022-11-07]
==> Notes <==
- Smallest to largest algorithm times, g(n)
        - 1
        - log(n)
        - (log(n))^2
        - n
        - n*log(n)
        - n^2
        - n^2*log(n)
        - n^3
        - n^k
        - 2^n
        - a^n
        - n!
        - n^n
    - Steps for algorithm analysis:
        - Identify critical operations
        - Count # of critical operations
        - express # crit ops as a function of the size of input
        - f(n) = O(g(n))

- Sorting
    - Given a collection [-9 2 -5 7 0 8 -3]
    - n = 7
    - The upper bound for a sorting aglorithm: n(n-1)/2
        - Comes from n choose 2
    - The lower bound for a sorting algorithm: n*log(n)
        - Absolute best case for any algorithm
    - Example:
        - Represented with ranks, i.e. 0 will end up in index 0, 3 in index 3
        - [3 1 5 7 0 2 6 4]
        - Start with first pair, 3 and 1
            - [{3 1} 5 7 0 2 6 4]
            - Need to be swapped
            - [1 3 5 7 0 2 6 4]
        - Next pair, 3 and 7
            - Ordered, no swap
        - Next pair, 5 and 7
            - Ordered, no swap
        - Next pair, 7 and 0
            - [1 3 5 {7 0} 2 6 4]
            - Swap
        - Next pair, 7 and 2
            - [1 3 5 0 {7 2} 6 4]
            - Swap
        - Next pair, 7 and 6
            - [1 3 5 0 2 {7 6} 4]
            - Swap
        - Next pair, 7 and 4
            - [1 3 5 0 2 6 {7 4}]
            - Swap
        - No more pairs
        - Always guaranteed that the largest ends up last
        - [1 3 5 0 2 6 4 7]
        - Stats
            - # of comparisons: n-1
            - # of swaps: 5
            - # of swaps potentially: [0,n-1]
        - Then reduce range by 1 since last index is correct
        - [{1 3 5 0 2 6 4} 7]
        - Continue until sorted
        - Stats for next swap
           - # of comparisons: n-2
            - # of swaps: 3
            - # of swaps potentially: [0,n-2] 
        - This method is !bubble sort!
        - Overall stats:
            - # of comparisons: n*(n-1)/2
            - # of swaps: [0, n*(n-1)/2]

    - Optimizing number of swaps
        - What if we find the largest first and bring it to the right position on one swap?
        - [3 1 5 7 0 2 6 4]
        - Grab 3, is 1 larger than 3?
            - No, keep 3
        - 3 < 5, now keep 5
        - 5 < 7, now keep 7
        - 7 > 0
        - 7 > 2
        - 7 > 6
        - 7 > 4
        - 7 is the largest
            - Swap 7 and the element in the last position
            - 7 and 4 swap
        - [3 1 5 4 0 2 6 7]
        - Stats
            - - # of comparisons: n-1
            - # of swaps: 1
            - # of swaps potentially: 0 or 1
        - Do not check last index now, already found
        - Repeat until list is sorted
        - Known as "Selection sort"
        - Overall stats:
            - # of comparisons: n*(n-1)/2
            - # of swaps: [0, n-1]
        - Same number of comparison, but less swapping

    - Another method
        - [3 1 5 7 0 2 6 4]
        - Comapre 3 and 1, swap
        - [{1 3} 5 7 0 2 6 4]
        - We now know the first 2 indices are sorted
        - Now check where 5 would fit in, compare against 3
        - [{1 3 5} 7 0 2 6 4]
        - Still sorted to start
            - Only needed to do 1 comparison, but if it was smaller we would need to do another
        - Now compare 7 to the end of the sorted array, which is 5
        - [{1 3 5 7} 0 2 6 4]
            - One comparison again
        - Now 0
        - [{1 3 5 (7} 0) 2 6 4]
            - Smaller than 7, smaller than 5, 3, 1, insert at beginning
        - [{0 1 3 5 7} 2 6 4]
            - Still sorted at the beginning
        - Now compare 2
            - 4 comparisons and swapped once
        - [{0 1 2 3 5 7} 6 4]
        - Now 6
            - 2 comparisons against 7 then 5
        - [{0 1 2 3 5 6 7} 4]
        - Finally 4
            - 4 comparisons
            - 1 swap
        - [{0 1 2 3 4 5 6 7}]
        - "Insertion sort"
        - Overall stats:
            - # of comparisons: n*(n-1)/2
            - # of swaps: [0, n*(n-1)/2]

==> TODO <==

